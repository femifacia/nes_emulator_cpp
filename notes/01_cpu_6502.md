## CPU

The CPU can
- Write an address (16 Bits)
- Read and Write Some Data (8-bit)
- Write if it is reading or writing ()

There is a clock connected to the cpu that indicates the state of the cpu and forces it to change.
When there is a state change, the CPU check if some data are available to be read or written

## The BUS

It is a wire that keep each element of the circuit connected.

There are some range from 0x0000 to ... and elements can be plug on it. Elements plugged have a range of adress o, which they are addressable

On the bus The CPU can output an address and reading or writing datas.
If the cpu is
- Writing some data, after having output the address, the element connected on the range of the address will read the data outputed by the cpu
- reading some data, after having output the address, the element connected on the range of the address will write some data which will be read back by the CPU

When cpu is reading from an adress that is not refering to anny device, it read in fact noise or the previous state of the bus


On this project at least the first part, the only elements to be connected on the bus will be:
- The cpu
- The RAM (64 KB: 0x0000 - 0xFFFF)

## RAM

It contains variable for our games, and the program itself (von neumann architecture)

## 6502 Memory

We have 3 main registers for a total of 8 - bit
- A: Accumulator
- X: Register
- Y: Register

We also have a
- (8 Bits) Stack pointer. It points to an adress somhere in the memory and incremante or decremante as we push or pull elements from the stack
- (16 bits) Program Counter. It store the address of the next programm byte the cpu needs to read. As the programm progresses the programm counter increases. Jump and branches
can directly set the value of the program Counter
- (8 bits) Status Register (contains bit which let us interogate about the state of the CPU) for ex: Was the last result equal to 0 ?Has there been a carry operation, Instruct the CPU to do Thng (Interruptions etc....)

Every time our CPU is clocked, it outputs the PC (program counter) on the bus, receives a single byte of instruction, do computation, and if necesary output some data

## Memory particularity

Not all byte instructions have the same length. Some can be 1 bit, others 2 or 3 bits


The PC doesn't simply incremeant per instruction

DIFFERENTS INSTRUCTIONS TAKE DIFFERENT LENGTH OF CLOCK CYCLE TO EXECUTE

Because of tbis, per instructions, we need to be concerned by the **size** of the instruction and the **duration** of the instruction. The 6502 a **56** Instructions can be mutated to change their size and duration depending of the arguments. FORTUNATELY, we can rely on the first bits of the instructions, containing all these informations

To illustrate this, let's suppose I want to load to the accumulator the value 65. In hexa 65 = 0x41. So it would be something like

    LDA $41

LDA (The instruction) is 1 Byte

$41 (the Value) is 1 Byte

So it is a 2 BYTE Instruction

Then, Let's suppose I want to Load on the accumulator an actual address. Addresses are 16 bits in the 6502 CPU nes env so it would be something like this

    LDA $0x89983

LDA is 1 Byte

0x89983 is 2 Bytes

The instruction is 3 Bytes

SUppose we want to clear the clear the carry bit, the status register, we will just write:

    CLC

CLC is 1 byte

It is 1 Byte instruction

So for each instruction, we need to emulate the **function** itself, the **address mode**, the **number of cycle** taken

## Instruction reading

There is a 16 * 16 matrix that give us for each instructions, the number of clock cycle (right) and the length of the instruction (left) and the address mode

## Opcodes

They are the functions programs can call on the cpu. There is a matrix where they are listed

## Addressing mode
An addressing mode defines **how the CPU determines the memory address (or the data) that an instruction will operate on**.

For example, an instruction like `LDA` (Load Accumulator) loads a value into the accumulator, but **depending on the addressing mode**, the source of that value changes.

---

### The main 6502 addressing modes (used in `olc6502`):

1. **Immediate**
    - The operand is given directly in the instruction.
    - Example: `LDA #$10` → loads **0x10** into A.
    - No extra memory access.
2. **Zero Page**
    - The address is a single byte, so limited to page 0 (`$00xx`).
    - Example: `LDA $42` → loads the value at `$0042`.
    - Fast (2 cycles), but only 256 bytes of space.
3. **Zero Page,X / Zero Page,Y**
    - Like zero page, but adds X or Y to the base address.
    - Example: `LDA $42,X` → loads from `$0042 + X`.
    - Wraps within page zero (no carry to higher byte).
4. **Absolute**
    - A full 16-bit address is given in the instruction.
    - Example: `LDA $1234` → reads from `$1234`.
5. **Absolute,X / Absolute,Y**
    - Like absolute, but adds X or Y to the base address.
    - Example: `LDA $1000,X` → reads from `$1000 + X`.
    - May take an extra cycle if a page boundary is crossed.
6. **Indirect**
    - Only used by `JMP`.
    - Example: `JMP ($1234)` → jumps to the 16-bit address stored at `$1234` and `$1235`.
    - ⚠️ 6502 quirk: if `$1234` is at the end of a page (`$xxFF`), the high byte is read from `$xx00` instead of the next page.
7. **Indirect,X (Pre-Indexed Indirect / Indexed Indirect)**
    - Example: `LDA ($40,X)`
    - Take `$40 + X` (in zero page), read the 16-bit address there, then load from that address.
    - Commonly used for pointer tables.
8. **Indirect,Y (Post-Indexed Indirect / Indirect Indexed)**
    - Example: `LDA ($40),Y`
    - Read the 16-bit address stored at `$40` (in zero page), then add Y to it.
    - May cost an extra cycle if crossing a page.
9. **Relative**
    - Used for branch instructions (`BEQ`, `BNE`, …).
    - Operand is a signed 8-bit offset.
    - Example: `BEQ LABEL` → jumps to PC + offset if condition is true.
10. **Implied**
    - No operand: the instruction operates directly on a register.
    - Example: `CLC` (Clear Carry), `INX` (Increment X).
11. **Accumulator**
    - The operand is the accumulator itself.
    - Example: `LSR A` → shifts A to the right.

---

In practice in the code (`olc6502`), each addressing mode is a function that:

1. Calculates the **effective address** (or immediate value).
2. Tells the CPU how many cycles the instruction will take.
3. Lets the opcode fetch/store at the right place.

## Workfloaw
- Read a Byte at the PC location
- Use this byte to read an array that represent the big table containging the function to execute and how to. 
OPCODE[Byte] -> ADDRESSING MODE, Number of cycles
- Read 0, 1, or 2 More bytes
- Execute the instruction
- Wait and count Cycles until instructions is finished

## Signals
We have 03 main signals
- reset();
- interupt_required(); //irq (interupr required signal) an be ignored wether the interrupt enable flag is setle
- non_masquable_interupt_request(); can never been disabled

all these 03 functions can occur every time and can interupt the work of the cpu. They are asynchronous

## Clock

Each instruction require a certain number of clock cycle to execute. But here we will juste do things when the cycle would be equal to zero

## Instructions

### Addition (ADC)

The principle is to add to the accumulator some data fetch from the memory and the carry bit.
By including the Carry bit, we can together additions of 8 bit words into larger bits one because if one Overflow, it will set the carry bit.
And we will use this carry later as an input to the next addition

`A = M + C`

For exemple let's suppose the accumumlator Has 250
We have
A = 250
M = 010

The result of this addition will be 4 in A because of course 250 + 10 = 260 but the max is 255. So the result will overflow and the carry gonna be
conserved inside C. If I am working with 16bits number, I can have somthing like this
High Low
High Low

The addition will be done to the Two lower parts of my two 16 bits int (don't forget each part is a 8bit sized int). If there is a carry, I can then add it to the result of the addition of the two high parts

BUT the problem is that sometime you will work with signed int and unsigned int at the same time

Let's suppose we have this number
10000100 = 128 + 4 = 132 if we are in the range [0, 255]
BUT IF WE ARE IN [-128, 127], 132 = -124 (Overflow of 5) So the binary higher would be in that case equal to -124